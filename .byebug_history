exit 
PROTECTED_PROPERTIES[1]
PROTECTED_PROPERTIES
value
PROTECTED_PROPERTIES.any? { |el| el =~ value.to_s }
prop
exit
Regexp.last_match(1)
/^:(.+)$/.match(value)
Regexp.last_match(1)
Regexp.last_match
Regexp.last_match(1)
Regexp.last_match
symbol?(value)
symbol?(value).last_match(1)
Regexp.last_match
Regexp.last_match(1)
Regexp.last_match(1).to_sym
symbol?(value)
continue
symbol?(value)
continue
symbol?(value)
exit
Regexp.last_match(1)
/^:(.+)$/.match(value)
$1
$
$~
Regexp.last_match
Regexp.last_match(
symbol?(value)
c
symbol?(value)
continue
symbol?(value)
continue
Regexp.last_match
/^:(.+)$/ =~ value
Regexp.last_match
$1
Regexp.last_match(1)
regexp?(value)
symbol?(value)
value
continue
next
Regexp.last_match(2).to_sym
Regexp.last_match(1).to_sym
/^:(.+)$/ =~ value
Regexp.last_match(1)
Regexp.last_match(:foo)
Regexp.last_match(1)
Regexp.last_match(value)
Regexp.last_match
/^:(.+)$/ =~ value
Regexp.last_match(1)
 $1.to_sym
 /^:(.+)$/.match(value)
Regexp.last_match(0)
Regexp.last_match(1)
value
regexp?(value)
continue
next
regexp?(value)
next
regexp?(value)
continue
value
return Regexp.last_match(1).to_sym if regexp?(value)
regexp?(value)
$1.to_sym
/^:(.+)$/.match(value)
/^:(.+)$/ =~ "Hello"
/^:(.+)$/ =~ value
value
exit
args
name
step
next
continue
def m_regexp?(value) /^:(.+)$/ =~ value;  end
def m_regexp?(value);/^:(.+)$/ =~ value  end
def m_regexp?(value);/^:(.+)$/ =~ value; end
    end
      /^:(.+)$/ =~ value
def m_regexp?(value)
reqexp?(value)
value
self.method(:regexp?).source_location
self.method(:reqexp?).source_location
reqexp?(value)
next
continue
next
continue
reqexp?(value)
value
self.method(:regexp?).source_location
self.method(:regexp?)
reqexp?(value)
/^:(.+)$/ =~ value
reqexp?(value)/^:(.+)$/ =~ value
reqexp?(value)
/^:(.+)$/ =~ value
reqexp?(value)
boolean_false?(value)
boolean_true?(value)
float?(value)
integer?(value)
/^[0-9]+$/ =~ value
value
integer(value)
value
continue
new_value
new_value = try_convert_value(new_value)
new_value.class == String
new_value = (value =~ /^["](.*)["]$/) ? Regexp.last_match(1) : value
 new_value = ''
 value = value.chomp.strip if value
line
param, value = line.split(/\s*=\s*/, 2)
raise ArgumentError, "Invalid pair: #{line}. Expected: name=value" unless line['=']
continue
@command_line = parse_setting data.split(delimiter).first
@command_line = data.split(delimiter).first
@command_line = data.split(delimiter)
@command_line = data.split(delimiter).map { |el| parse_setting(el) if el }
@command_line = data.split(delimiter).map { |el| parse_setting(el) if el }.compact.to_h
data.split(delimiter)
data = ENV[config.env_variable_with_options]
data
data.split(delimiter)
data.split(delimiter).
delimiter = ENV['SEXY_SETTINGS_DELIMITER'] || config.cmd_line_option_delimiter
ENV[config.env_variable_with_options]
config.env_variable_with_options
c
config
continue
ENV.keys.sort
ENV.keys
ENV
config
